TARGET DECK
Code::Mysql

### 1 存储引擎

#### 1.1 MySQL InnoDB引擎中的聚簇索引和非聚簇索引有什么区别？
聚簇索引的`非叶子节点`存储的是`索引值`，`叶子节点`存储的是`完整的数据记录`，一个表只能有`一个`聚簇索引，一般是表的主键，主要用于范围查询和排序。
非聚簇索引的`非叶子节点`存储的也是`索引值`，但是`叶子节点`存储的是`数据行的主键`或`对应的索引列`，一个表可以有`多个`非聚簇索引，非聚簇索引由称为`辅助索引`，`二级索引`等，主要用于`快速定位`要查找的列。
<!--ID: 1737942348476-->


#### 1.2 MySQL的存储引擎有哪些?它们之间有什么区别？
通过访问MySQL官网可以了解到，在`8.4版本`MySQL提供了`10个引擎`，主要的存储引擎为：`InnoDB(重点)`，`MyISAM(重点)`，`MEMORY`，`NDB(NDBCluster)`，`ARCHIVE`。着重讲两个常用的基于`B+tree索引`的存储引擎，
**InnoDB（MySQL5.5.5后默认引擎）**
特点：
1. 支持`事务`、`行级锁`、`外键`
2. 存储限制`64TB`
3. 支持`数据缓存`、`聚簇索引`、`多版本并发控制（MVCC）`
4. `读写阻塞与事务隔离级别`有关
5. 支持全文索引（MySQL5.5后）
6. `tb_name.frm` 每表表结构，`tb_name.ibd` 数据行和索引
7. 适用`高负载的OLTP应用`
**MyISAM（MySQL5.5.5前默认引擎）**
特点：
1. 不支持`事务`、`外键`、`行级锁`（最小锁粒度为`表锁`）
2. 存储限制为`256TB`
3. 不支持`数据缓存`（只支持索引缓存）、`聚簇索引`、`多版本并发控制（MVCC）`
4. 读写互相阻塞
5. 读取数据较快，占用资源较少
6. `tbl_name.frm` 表结构，`tbl_name.MYD` 数据行，`tbl_name.MYI` 索引
7. 适用`读多写少、表较小的场景`
<!--ID: 1737942348480-->

### 2 索引
#### 2.1 MySQL的索引类型有哪些？
- **B+树索引**：通过树形结构存储数据，适用于范围查询和精确查询，支持有效数据的快速查找、排序和聚合操作，MySQL的默认索引类型，常用于InnoDB和MyISAM。
- **哈希索引**：基于哈希表的结构，适用与等值查询，但不支持范围查询，查询速度很快，同时不存储数据的顺序，常用于Memory引擎
- **倒排索引**：它将文档集合中的每个唯一单词（词条）映射到包含该单词的所有文档列表，倒排索引通过将单词作为索引的键，文档列表作为值，实现了从单词到文档的快速查找，而全文索引通常依赖倒排索引这种数据结构来实现
- **R-树索引**：为了多维空间数据（地理坐标）设计，适用于空间查询（计算最近距离，区域查询等）。常用于存储和查询地理信息系统（GIS）中的空间数据
- **聚簇索引**：索引的叶子节点存储完整数据记录
- **非聚簇记录**：索引的叶子节点存储了主键值和对应的索引字段
- **普通索引**：一般指非主键索引且非唯一索引（二级索引、辅助索引 ）
- **主键索引**：唯一且不能为NULL，每个表只能有一个，InnoDB中主键索引是聚簇索引结构实现的
- **联合索引**：多个列组成的索引，适用于多列的查询条件，也可以通过联合索引实现覆盖索引和索引下推技术
- **唯一索引**：唯一，允许为null，但一个列中可以有多个null，可以有效防止重复数据的插入
- **全文索引**：准确来说是一种索引技术，通常依赖倒排索引这种数据结构实现，针对文本数据的一种索引机制，能让用户对文本内容进行全面检索
- **空间索引**：具体来说是一个宽泛的概念，旨在为空间数据提供一种高效的组织和检索方式，R-树索引就是空间索引的具体实现方式。
- **位图索引**：一种在数据库管理中适用的特殊索引结构，特别适用于处理低基数（列中不同值的数量相对较少）的数据列（例如男女性别）。
<!--ID: 1737942348485-->


#### 2.2 MySQL三层B+树能存多少数据？
一般这种题，更多的是考察对于MySQL存储格式的了解，后续遇到类似的面试题该如何思考？接下来按步骤分析以下。
1. 了解MySQL的存储格式及对应的结构（如每页默认大小16KB，B+树的结构）
2. 假设数据大小，估算每页可存储数据数量
3. 假设索引键和指针大小，估算单个节点的扇出数量
4. 通过（单页存储数据量×单个节点的扇出量2 ）计算总数据量，这里三层就是2次方，n层就是n-1次方。
<!--ID: 1737942348489-->


#### 2.3 MySQL的最左前缀匹配原则是什么？
MySQL 索引的最左前缀匹配原则指的是在使用**联合索引**时，查询条件必须从索引的最左侧开始匹配。如果一个联合索引包含多个列，查询条件必须包含第一个列的条件，然后是第二个列，以此类推。
**底层原理**：因为联合索引在 B+ 树中的排列方式遵循“从左到右”的顺序，例如联合索引 `(first_name, last_name, age)` 会按照 `(first_name, last_name, age)` 的顺序在 B+ 树中进行排序。
MySQL 在查找时会优先使用 `first_name` 作为匹配依据，然后依次使用 `last_name` 和 `age`。因此，组合索引能够从左到右依次高效匹配，跳过最左侧字段会导致无法利用该索引。
按照 `(first_name, last_name, age)` 的顺序在 B+ 树中的排列方式(大致的示意图)如下
```
						(Alice, Black, 35)
                              |
      -------------------------------------------------------------
      |                |                     |                |
    (Alice, Brown, 25)  (Alice, Smith, 30) (Bob, Smith, 20) (Bob, White, 19)
```
<!--ID: 1737942348492-->


#### 2.4 为什么MySQL选择使用B+树作为索引结构？
- **支持范围查询**，B+树在进行范围查找时，只需要从根节点一直遍历到叶子节点，因为数据都存储在叶子节点上，而且叶子节点之间有指针连接，可以很方便地进行范围查找。
- **支持排序**，B+树的叶子节点按照关键字顺序存储，可以快速支持排序操作，提高排序效率；
- **存储更多的索引数据**，因为它的非叶子节点只存储索引关键字，不存储实际数据，因此可以存储更多的索引数据；
- **在节点分裂和合并时，IO操作少**。B+树的叶子节点的大小是固定的，而且节点的大小一般都会设置为一页的大小，这就使得节点分裂和合并时，IO操作很少，只需读取和写入一页。
- **有利于磁盘预读**。由于B+树的节点大小是固定的，因此可以很好地利用磁盘预读特性，一次性读取多个节点到内存中，这样可以减少IO操作次数，提高查询效率。
- **有利于缓存**。B+树的非叶子节点只存储指向子节点的指针，而不存储数据，这样可以使得缓存能够容纳更多的索引数据，从而提高缓存的命中率，加快查询速度。
<!--ID: 1737942348496-->


#### 2.5 红黑树、B树、B+树的区别
| **比较项目** | **红黑树**                                  | **B 树**                        | **B + 树**                        |
| -------- | ---------------------------------------- | ------------------------------ | -------------------------------- |
| 定义       | 一种自平衡的二叉查找树，通过红黑着色和旋转操作保持平衡              | 一种平衡的多路查找树，允许每个节点包含多个关键字和多个子树  | B 树的变形，所有数据存储在叶子节点，叶子节点间有链表相连    |
| 节点结构     | 每个节点包含一个关键字、两个子节点指针以及颜色属性                | 每个节点包含多个关键字和多个子节点指针            | 非叶子节点只存储索引，叶子节点存储所有数据及链表指针       |
| 树的高度     | 较高，为 O (log n)，n 为节点数                    | 相对较低，与节点能容纳的关键字数量有关            | 相对 B 树更低，同样依赖于节点容纳的关键字数量         |
| 查找效率     | O (log n)，适用于内存中数据的快速查找                  | 减少磁盘 I/O 次数                    | 在范围查找上更高效                        |
| 插入删除操作   | 插入和删除后需要通过旋转和重新着色来保持平衡，操作相对复杂            | 插入可能导致节点分裂，删除可能导致节点合并，操作涉及节点调整 | 类似 B 树，但可能需要额外调整叶子节点的链表          |
| 数据存储位置   | 数据存储在每个节点中                               | 数据存储在每个节点中                     | 所有数据存储在叶子节点                      |
| 应用场景     | 常用于内存中的数据集合，如 Java 的 TreeMap、C++ 的 map 等 | 文件系统和数据库系统中，用于存储索引数据           | 数据库系统的索引结构，如 MySQL 的 InnoDB 存储引擎 |
<!--ID: 1737942348500-->

#### 2.6 MySQL中使用索引一定有效么？
**不一定有效**
- **查询条件中不包含索引列**
- **低基数列索引效果不佳**
- **查询条件复杂且不匹配索引的顺序**
- **对于小表，全表扫描可能比使用索引开销更小**
<!--ID: 1737944967620-->


#### 2.7 在MySQL中建立索引时需要注意哪些事项？
简单总结了以下六点：
1）不能盲目的建立索引，**索引并不是越多越好**，索引会占用空间，且每次修改的时可能都需要维护索引的数据，消耗资源。
2）对于字段的值有**大量重复的不要建立索引**。比如说：性别字段，在这种重复比例很大的数据行中，建立索引也不能提高检索速度。**但是也不绝对**，例如定时任务的场景，大部分任务都是成功，少部分任务状态是失败的，这时候通过失败状态去查询任务，实际上能过滤大部分成功的任务，效率还是可以的。
3）对于一些**长字段不应该建立索引**。比如 text、longtext 这种类型字段不应该建立索引。因为占据的内存大，扫描的时候大量加载至内存中还耗时，使得提升的性能可能不明显，甚至可能还会降低整体的性能，因为别的缓存数据可能因为它被踢出内存，下次查询还需要从磁盘中获取。
4）当**数据表的修改频率远大于查询频率**时，应该好好考虑是否需要建立索引。因为建立索引会减慢修改的效率，如果很少的查询较多的修改，则得不偿失。
5）对于需要频繁作为条件查询的字段应该建立索引。在 where 关键词后经常查询的字段，建立索引能提高查询的效率，如果有多个条件经常一起查询，则**可以考虑联合索引，减少索引数量**。
6）对经常在 order by、group by、distinct 后面的字段建立索引。这些操作通常需要对结果进行排序、分组或者去重，而索引可以帮助加快这些操作的速度。
<!--ID: 1737944967628-->

#### 2.8 MySQL中的回表是什么？
"回表" 是指在使用二级索引（非聚簇索引）作为条件进行查询时，由于二级索引中只存储了索引字段的值和对应的主键值，无法得到其它数据。如果要查询数据行中的其它数据，需要根据主键去聚簇索引查找实际的数据行，**这个过程被称为回表**。